import Page from "@reason/pages/Docs";
export default Page({
  title: "Advanced Concepts | Mina Protocol",
  description: "Check out these advanced concepts regarding zkApps.",
});

# Advanced Concepts

Build onto what you already learned regarding zkApps and SnarkyJS

This page explores additional topics that requires some familiarity with building zkApps, SnarkyJS, and crytography.

## Events

Events represent arbitrary information that can be passed along with a transaction.

An example use case are zkApps which keep some large internal state, and only store a commitment to that internal state on-chain. For example, a Merkle tree where only the root is stored in on-chain state. Events enable to attach the full information of state changes in transactions. In the Merkle tree example, this could mean sending any Merkle leaves that are changed by the transaction as events. This means that an observer of these transactions can follow along and keep track of the full Merkle tree on their side.

To use events, you have to declare an `events` field at the top level of your smart contract. It contains the _names_ and _types_ of your events. Here's an example:

```ts
class MyContract extends SmartContract {
  events = {
    "add-merkle-leaf": Field,
    "update-merkle-leaf": Field,
  };
}
```

In this example, we declare events called `"add-merkle-leaf"` and `"update-merkle-leaf"`, both with a type of `Field`. Instead of `Field`, you can also use other built-in snarkyjs types as well as any `CircuitValue`. (In fact, a custom `CircuitValue` is probably better-suited to encode leaves of a Merkle tree -- we just use `Field` for simplicity here.)

After declaring your events, you can use `this.emitEvent(name, event)` in any smart contract method, where `event` has to have the type you declared for that `name`. Example:

```ts
class MyContract extends SmartContract {
  events = {
    "add-merkle-leaf": Field,
    "update-merkle-leaf": Field,
  }

  @method updateMerkleTree(leaf: Field, ...) {
    this.emitEvent("update-merkle-leaf", leaf);
    // ...
  }
}
```

Some other important facts about events:

- Events are not stored on-chain. Only events from the last couple of transactions will be kept by consensus nodes; after that, they will be discarded.
- However -- like other transaction history -- events will stay accessible from archive nodes. In the near future, we plan to add an API to easily fetch events for any smart contract from an archive node.
- You can't refer to previously emitted events in a smart contract, because there is no way of proving that the events you refer to are actually the events emitted to that contract.

This is all you need to know about events! Think of them as a convenience feature -- a light-weight way of attaching information about your smart contract execution, which would otherwise get lost. Don't treat them as fully-fledged storage which can be safely accessed in smart contracts.

### Events: API reference

```ts
class SmartContract {
  static events?: Record<string, any>;

  emitEvent(name: string, event: any): void;
}
```

## Actions and Reducer

<Alert kind="info">Experimental. This API may change.</Alert>

Like events, **actions** are arbitrary information passed along with a zkApp transaction. However, actions give you an additional power: you can process previous actions in a smart contract! Under the hood, this is possible because we store a commitment to the history of dispatched actions on every account -- the **actionsHash**. It allows us to prove that the actions you process are, in fact, the actions that were dispatched to the same smart contract.

Using actions and a pattern we call "lagging state", you can write zkApps that can _process concurrent state updates by multiple users_. See the next section, where this will be described in detail. Besides that, we imagine all kinds of use cases where actions act as a built-in, "append-only" off-chain storage layer.

To use actions, we first have to declare their type on the smart contract. The object we declare is called a **reducer** -- because it can take a list of actions and reduce them:

```ts
import { SmartContract, Experimental, Field } from "snarkyjs";

class MyContract extends SmartContract {
  reducer = Experimental.Reducer({ actionType: Field });
}
```

Contrary to events, for actions you only have one type per smart contract; they also don't have a name. This will make sense in a minute. The `actionType` in this example is `Field`.

On a `reducer`, you have two functions: `reducer.dispatch` and `reducer.reduce`. "Dispatch" is simple -- like emitting events, it will push one additional action to your account's action history:

```ts
this.reducer.dispatch(Field(1000));
```

"Reduce" is more involved, but it gives you full power to process actions however it suits your application. It might be easiest to grasp from an example. Say we have a list of actions and want to find out if one of them is equal to `1000`. In JavaScript, there's a built-in function on `Array` which does this:

```ts
let has1000 = array.some((x) => x === 1000);
```

However, as you might know, you can also implement this with `Array.reduce`:

```ts
let has1000 = array.reduce((acc, x) => acc || x === 1000, false);
```

In fact, `Array.reduce` is powerful enough to let you do pretty much all array processing you can think of. With `Reducer.reduce`, we give you an in-snark operation which is just as powerful:

```ts
// type for the "accumulated output" of reduce -- the `stateType`
let stateType = Bool;

// example actions data
let actions = [[Field(1000)], [Field(2)], [Field(100)]];

// state and actionsHash "before" applying actions
let initial = {
  state: Bool(false),
  actionsHash: Experimental.Reducer.initialActionsHash,
};

let { state, actionsHash } = this.reducer.reduce(
  actions,
  stateType,
  (state: Bool, action: Field) => state.or(action.equals(1000)),
  initial
);
```

What we called `acc` above is now called `state`; we also have to pass in the state's type as a parameter. In addition, we have to pass in an `actionsHash` which refers to one particular point in the actions history. Like `Array.reduce`, `Reducer.reduce` takes a callback which has the signature `(state: S, action: A) => S`, where `S` is the `stateType` and `A` is the `actionType`. It returns the result of applying all the actions, in order, to the initial `state`. In this example, the returned `state` will be `Bool(true)`, because one of the actions in the list is `Field(1000)`. Reduce also returns the new actionsHash -- so you can store it and for using it when you reduce the next batch of actions. One last difference to JS reduce is that this takes a _list of lists_ of actions instead of a flat list. Each of the sublists are the actions that were dispatched in one account update (e.g., while running one smart contract method).

### Reducer - API reference

```ts
reducer = Experimental.Reducer({ actionType: AsFieldElements<A> });

this.reducer.dispatch(action: A): void;

this.reducer.reduce<S>(
  actions: A[][],
  stateType: AsFieldElements<S>,
  reduce: (state: S, action: A) => S,
  initial: { state: S, actionsHash: Field }
): { state: S, actionsHash: Field };

Experimental.Reducer.initialActionsHash: Field;
```

The above API is available now, but still marked as "Experimental". In the near future, we want to add a function to retrieve actions from an archive node:

```ts
this.reducer.getActions(fromActionsHash?: Field, toActionsHash?: Field): A[][];
```

### Actions and "lagging state" -- handling concurrent updates

TODO
